##### 锁的一些特性

- 可重入性：记录线程获取锁的次数，在退出代码块时，计数器减一，直到计数器清零
- 不可中断性：一个线程获取锁之后，其他线程只能等待锁的释放，不可中断

##### 偏向锁

- jdk1.6后默认启动，可以通过该参数关闭：-XX:-UseBiasedLocking

- 默认程序启动后有4000ms的延迟，之后进入可偏向未偏向状态（匿名偏向），可以通过该参数修改延迟：-XX:BiasedLockingStartupDelay

- 偏向锁启用后，Mark Word中的偏向锁标志位为1，并用54bit记录了当前获取锁的线程的id

- 关于mark word中存储信息的问题
  - 对象头在无锁状态下（001），mark word 中可储存对象的Identity hash code，若对象已计算过Identity hash code,对象将无法进入偏向锁状态；
  - 对象已进入偏向锁，若需要计算Identity hash code，则会发生偏向锁的撤销，然后锁膨胀为轻量级锁或重量级锁；Identity hash code是未被覆写java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。
  - 轻量级锁的实现中，会通过线程栈帧的锁记录存储Displaced Mark Word；重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。
  
- 偏向锁撤销：当发生锁竞争或计算Identity hash code时，需要等到safe point，将偏向锁升级为重量级锁或轻量级锁，这会消耗一定的性能

- 当一个类的对象总是因为锁竞争引起锁膨胀，导致了大量的偏向锁撤销操作，明显会导致性能下降，此时需要进行偏向锁的批量重偏向或批量撤销，类元数据类有个属性记录了锁撤销次数

  - 此参数决定了何时批量重偏向，默认为20：-XX:BiasedLockingBulkRebiasThreshold
  - 此参数决定了何时批量撤销，默认为40：-XX:BiasedLockingBulkRevokeThreshold
  - 此参数为重置偏向锁撤销次数的时间间隔,默认25000：-XX:BiasedLockingDecayTime

- 偏向锁逻辑：

  1. 线程A第一次访问同步块时，先检测对象头Mark Word中的标志位是否为01，依此判断此时对象锁是否处于无所状态或者偏向锁状态（匿名偏向锁）；

  

  2. 然后判断偏向锁标志位是否为1，如果不是，则进入轻量级锁逻辑（使用CAS竞争锁），如果是，则进入下一步流程；

  3. 判断是偏向锁时，检查对象头Mark Word中记录的Thread Id是否是当前线程ID，如果是，则表明当前线程已经获得对象锁，以后该线程进入同步块时，不需要CAS进行加锁，只会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。

  -  偏向锁重入,退出同步块释放偏向锁时，则依次删除对应Lock Record，但是不会修改对象头中的Thread Id；

  - 注：偏向锁撤销是指在获取偏向锁的过程中因不满足条件导致要将锁对象改为非偏向锁状态，而偏向锁释放是指退出同步块时的过程。


  4. 如果对象头Mark Word中Thread Id不是当前线程ID，则进行CAS操作，企图将当前线程ID替换进Mark Word。如果当前对象锁状态处于匿名偏向锁状态（可偏向未锁定），则会替换成功（将Mark Word中的Thread id由匿名0改成当前线程ID，在当前线程栈中找到内存地址最高的可用Lock Record，将线程ID存入），获取到锁，执行同步代码块；

  5. 如果对象锁已经被其他线程占用，则会替换失败，开始进行偏向锁撤销，这也是偏向锁的特点，一旦出现线程竞争，就会撤销偏向锁；

  6. 偏向锁的撤销需要等待全局安全点（safe point，代表了一个状态，在该状态下所有线程都是暂停的）,暂停持有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前JVM的所有线程，如果能找到，则说明偏向的线程还存活），如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；

  - 注：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，并设置偏向线程ID；每次解锁（即执行monitorexit）的时候都会从最低的一个Lock Record移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。


  7. 如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向，如果不允许重偏向，则撤销偏向锁，将Mark Word设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS竞争锁；

  8. 如果允许重偏向，设置为匿名偏向锁状态,CAS将偏向锁重新指向线程A（在对象头和线程栈帧的锁记录中存储当前线程ID）；

  9. 唤醒暂停的线程，从安全点继续执行代码。

##### 公平锁与非公平锁

- 公平锁即先